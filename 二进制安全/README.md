# 二进制软件安全

## 原理（笔记）

### 二进制安全总述

+ 二进制安全是整个软件安全中核心的内容。因为二进制是软件的最基本形态。
+ 所有的基础软件都是以二进制软件的形式存在的。包括操作系统、浏览器、数据库、中间件、各种脚本软件的解释执行器。还有很多大型游戏等等。都是二进制软件。
+ 二进制软件的基本特征，是它是CPU可以直接运行的机器指令。所以不同平台的二进制软件是不同的，二进制程序，无法跨平台。也就是Intel架构的cpu的二进制无法在ARM架构上运行，反之也是。
+ CPU能够运行的机器指令都是二进制的，包括了很多非ASCII的不可打印字符。同时二进制程序还需要操作系统的支持，所以二进制形式的软件也是无法做到跨操作系统运行的。
+ 但是，软件的开发，人对二进制或者十六进制的数据阅读比较困难。如果直接使用二进制或者十六进制进行编程，那么效率会非常低下。所以我们编程的时候都不是直接处理二进制的。
+ 于是我们发明了一种直接使用文本来编程的方式，但是我们编写出来的文本代码，CPU并不能理解执行。所以，还需要一个转换和处理的过程，这个过程就是编译和链接。程序员编写出来的文本形式的代码，成为源代码，编译后生成的机器可运行的代码，称为目标代码。
+ 我们首先发明的源代码是汇编形式的，是使用的和机器指令一一对应的汇编语言。是一种直接最简单的操作指令级别的翻译过程。汇编的编程还不是很方便，后来发明了C语言等高级语言，高级语言不止C语言一种，但是c比较成功。其实C语言已经比较成功了，又发明了C++。
+ 软件安全研究的核心问题，就是两个，如下

### 漏洞挖掘--安全问题（存在性问题）

+ 由于软件安全的漏洞都是具体的，都是由软件内部的代码的编程不慎所引起的。所以漏洞挖掘，其方法就是分析代码。
+ 但是前面提到了，二进制的机器指令序列构成的软件，人解读起来很麻烦，我们如果直接读二进制，效率及其低下。所以我们通过是在了解了二进制机器指令的基本原理后。通过一些辅助的工具来解读。
+ 但是呢，通过安全人员分析软件的时候，只有二进制这个目标。比如，我们是一家安全公司，我们捕获了一个攻击程序。我们能拿到源代码吗？当然不能，源代码在发起攻击的人，也就是黑客的手上。
+ 所以很多时候，我们只能分析二进制。在只有二进制的情况下，我们有什么方法呢？
+ 我们通过逆向工程的一些技术，把二进制软件解构、翻译，然后就能理解其实现的原理。
+ 第一个方法就是反汇编、以及在汇编代码上的一些解构、比如获得函数列表、获得每个函数的调用关系、获得函数内部的控制流程图。这些是可以从二进制中获得信息，那是是不能逆向出来的呢？变量名、函数名、注释、一些数据类型。这些是源代码层面方便程序员的，对于二进制软件来讲，名称信息没有用处，机器指令内部全部是使用“数据和代码的存储地址”。
  + 反汇编，有一些工具可以使用。基本的如dumpbin、objdump高级的有IDA-pro等。
  + 另外，所有的调试器也都有反汇编功能。第二重要的工具就是调试器。调试器其实比反汇编器要高级很多。因为反汇编器只能在程序没有运行起来的时候去观察它，而调试器可以在程序运行起来以后，随时中断程序的运行并观察。当时是运行时的信息要丰富的多。比如运行时候可以看到用户输入的数据、外部读入的数据、这些数据的具体处理过程，某个变量在运行时的赋值情况等。这些信息都是静态的反汇编所没有的。
  + 调试器还要一个反汇编器说没有的功能，就是它能捕获程序执行的异常。异常信息，在软件分析的过程中，是非常重要的，因为二进制软件的安全问题，通常会引起程序运行时的内部数据结构被破坏，比如各种溢出，其实是覆盖了正常的数据。那内部数据结构被破坏以后，程序在后续执行时，可能访问这些不正常的数据，进而引起运行时错误。大多数运行时错误，最后都变成内存访问的异常。

+ 但是只有这些工具，距离发现具体问题，还有距离。我们得了解具体漏洞产生的原因，比如溢出，为什么溢出是严重的安全问题。前面也讲过。如果我们一行行看他的代码（还不是源代码、是二进制反汇编代码）那么是不是需要和开发人员同等数量的人员和时间呢？所以漏洞的挖掘，极少情况下会直接人工分析源代码。
+ 到现在为止，我们已经发明出了两大类自动化工具了。
  + 模糊测试工具（也叫Fuzzing）
    + 这种工具认为软件很复杂，我们干脆不要去看内部了，把软件当做一个黑盒子。只看它的外部表现，给它各种各样的输入，看它在处理过程中会不会出现异常，如果有异常就说明软件在设计的过程中，没有考虑到用户会输入这种样子的数据，和软件的预期不符合。那么预期不符，有接纳了这样的数据处理了，那是不是漏洞啊。就是的。
    + 这要通常会引起程序的崩溃，刚才我们又说了，调试器就用捕获程序异常功能。所以我们用调试器来捕获这要的异常，是不是就能实现自动化了。
    + 通过研究漏洞的原理，我们知道，漏洞是畸形的数据数据引起的，比如输入了一个超长的字符串，比程序员内部预留的长了，就溢出了。所以这种输入畸形数据去尝试触发崩溃的方法，理论上也是可行的。
    + 那怎么构造畸形数据呢？最直接的方法就是随机。随机并不是每次都能构造出正好合适的畸形数据，但是量大了以后很有可能有那么一两次。随意我们就随机的构造大量的数据。
    + 好在，软件虽然复杂，但是运行速度很快啊。这正是计算机的优势嘛。所以我们可以不停的去运行目标软件，让他来处理这些随机构造的可能是畸形的数据，然后运行的时候启动调试器来捕获可能得异常，虽然不是每次都能触发异常。我们可以一直不停的让程序自动运行。
  + 程序分析工具
    + 这种方法把是要深入软件的内部原理的，要去分析它的每一行代码。这里面代表的技术比如危险函数定位和符号执行等。
    + 危险函数定位的思路是，既然strcpy等能引起缓冲区溢出，那么我就把全部的strcpy找出来看一看。
    + 这个方法呢，简单了点。随着研究的深入，人们发现，不是所有的漏洞都是危险函数引起的，内存操作的方法各种各样，千奇百怪。而且不是所有的危险函数都会引起安全问题。比如调用之前进行了长度判断，就不会。所以这种方法效果很差。
    + 分析方法，逐步复杂，现在的代表方法是符号执行。

### 漏洞利用 --安全问题的可利用性问题

+ 漏洞挖掘技术现在是攻防双方都在使用。软件的开发人员也在采用黑客发明的漏洞挖掘技术来挖自己的漏洞，以争取在软件发布前把安全问题尽量发现和修补了。

+ 漏洞利用技术。上节课我们重点讲了shellcode。编写exp（漏洞利用程序）也是软件安全研究人员的基本功。

+ exp一般分为攻击数据部分，比如一个超级长的字符串，用来溢出缓冲区；和攻击成功后的控制部分，就是shellcode。shellcode很多时候可以通用，但是攻击数据部分，每个漏洞都不一样。

+ 这部分的学习，比较有效的办法就是去阅读和使用别人写好的exp。`kali Metasploit exploit-db`上有很多这样的程序，有一些安全研究人员的个人博客上也有很多。

+ 所以大家就去找一两个公开了exp的具体的漏洞，搭建漏洞环境，解读学习exp。这个是一种重要的学习方法，我们称为漏洞复现。

+ 那么哪里去找别人已经挖掘发现的漏洞呢？

+ 一开始，一些软件厂家，比如微软会定期升级自己的系统，打补丁。在打补丁升级系统的时候，就会同时给出安全公告，说他修补了那些问题。

+ 但是并不是每个软件厂家都有能力或者意愿去维护一个安全漏洞。有一些第三方的组织就来收集各种漏洞，并形成了一个统一的数据库，比如CVE。

+ CVE给每个漏洞都编写，说明漏洞影响的软件及其版本，危害程度等等详细信息。少量的漏洞还会给出PoC，也就是概念验证程序。

+ 早期的漏洞很多都有PoC，因为那个时候，很多软件厂家不重视漏洞修补工作。漏洞的发现人员，或者安全厂商放出PoC也能逼迫软件厂商去修补。

+ 现在，软件漏洞的披露已经很规范了。国家也重视，所有美国和我们有国家安全漏洞数据库，美国有`NVD`，我们国家的`CNVD`和`CNNVD`。

+ 这些都是大家去找已经公开的漏洞的地方。如果我们拿到了一个漏洞的详细公告，也拿到了PoC，我们如何去复现这个漏洞呢？当然是得安装一个有漏洞存在的软件版本。这个过程中，一个重要的工具就是虚拟机。我们通常在虚拟机里安装配置。因为漏洞需要的环境可能和我们的工作主机的环境冲突很大。而且漏洞环境复现过程中，可能会破坏系统。如果我们要复现很多漏洞，不在虚拟机中进行，会把自己的工作环境弄得很乱。所以VirtualBox等虚拟机软件也是我们经常要用的工具。

  + 虚拟机
    + 借助的物理CPU的虚拟化功能，而模拟器是使用软件来“实现”了一个CPU及其附属的设备。所以虚拟机的host系统和guest系统，只能是同一架构的，比如物理主机是intel架构，那么host和guest都这能是Intel 0x86架构的系统，比如Windows和Linux x86
  + 模拟器
    + 和虚拟机类型的，还有模拟器。模拟器和虚拟机相似又不同。他们都是在内部构造了一个“虚拟的机器”这个虚拟的机器可以和真实的机器一样安装和运行操作系统以及各种软件
    + 拟器就可以跨架构。host是Windows x86，guest是arm架构的安卓系统。模拟器的典型代表是[QEMU](https://www.qemu.org/)
    + 如果我们要研究安卓系统、路由器等MIPS架构的系统，就需要模拟器。模拟器通常也有调试、单步运行等功能。除了用于漏洞复现，也可用于漏洞挖掘。
    + 比如我们要挖掘一个路由器的漏洞，我们不能直接对着物理路由器Fuzzing，因为就是触发了异常，也无法捕获。所以通常是把固件提取出来，在模拟器中运行。

  

### 软件攻防

+ 黑客如果通过攻击，进入到了一个目标系统。那么他除了要考虑窃取信息、加密硬盘（勒索软件）、破坏数据等攻击之外，还需要考虑一个问题。第一是不留痕迹，第二是不能被杀毒软件和主机中的一些防御系统识别。
+ 早期，安全研究人员也在想办法对抗漏洞攻击和计算机病毒（计算机病毒其实就是一个可以自我复制的漏洞利用程序）。
+ 他们想到的办法就是杀毒软件，杀毒软件的基本原理是把已经发现的病毒等各种恶意程序的特征值记录在数据库中。每当系统中有新的文件时就计算一下这个文件的特征值，然后和数据库中的特征值进行比较。如果匹配上了，说明这是一个恶意程序。
+ 特征值通常是hash值。因为恶意软件很多，我们不可能把整个恶意软件都作为特性，占用空间也不方便分发特征值。（分发特征值就是病毒升级）。
+ 但是学过密码学的同学都知道，如果源数据稍微变化一下，hash值就变化了。比如病毒修改自己的一个无意义的常量数据，功能不变，杀毒软件就无法查杀了。
+ 所以后来有发明了动态的基于行为的检测。
+ 总之呢，恶意软件需要隐蔽自己。比如文件、进程、通讯的端口都需要隐藏起来。这就是rootkit技术。rootkit技术，很多是基于我们上个学期讲的API hook。通过挂钩API，篡改了操作系统的行为，当防御软件在列举目录中文件时，根本就获取不到攻击程序的文件。
+ 防御软件和攻击软件就是一个技术博弈，此消彼长的过程。产生了非常多很有意思的技术。比如攻击软件为了不被发现，根本就不产生文件。我们都知道可执行程序首先是一个文件，在系统上创建进程运行。后来出现了根本不产生文件，也不修改其他文件，寄生在其他可执行程序进程中、直接从网络加载到内存就能运行的恶意程序。
+ 软件攻防的技术，还衍生出另外一大类恶意软件。就是外挂。外挂程序也是通过修改正常程序的软件行为，比如直接篡改内存中的数据，或者挂钩其函数，达到修改软件行为的目的。
+ 开发和防御外挂软件的技术与软件攻防技术相似。都是需要使用逆向工程工具、调试器等等、都需要大量的数据分析工作。

